<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>背景透過ブラシツール</title>
  <style>
    :root { --gap: 10px; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; margin: 0; padding: 16px; color: #222; }
    h2 { margin: 0 0 12px; }
    .toolbar { display: grid; grid-template-columns: 1fr; gap: var(--gap); margin-bottom: 12px; }
    .row { display: flex; flex-wrap: wrap; gap: var(--gap); align-items: center; }
    .btn { padding: 8px 12px; border: 1px solid #ccc; border-radius: 8px; background: #fff; cursor: pointer; }
    .btn:disabled { opacity: .5; cursor: not-allowed; }
    .seg { display: inline-flex; border: 1px solid #ccc; border-radius: 8px; overflow: hidden; }
    .seg input { display: none; }
    .seg label { padding: 8px 12px; cursor: pointer; user-select: none; }
    .seg input:checked + label { background: #222; color: #fff; }
    .slider { display: inline-flex; gap: 8px; align-items: center; }
    .warn { color: #b14; font-size: 12px; }
    .hint { color: #666; font-size: 12px; }
    canvas { max-width: 100%; height: auto; border: 1px solid #d0d0d0; background: conic-gradient(from 45deg, #eee 0 25%, #fff 0 50%) center/20px 20px; touch-action: none; }
  </style>
</head>
<body>
  <h2>背景透過ブラシツール</h2>

  <div class="toolbar">
    <div class="row">
      <input type="file" id="upload" accept="image/*" />
      <button id="saveBtn" class="btn" disabled>保存（PNG透過）</button>
      <button id="downloadBtn" class="btn" disabled>ダウンロード</button>
      <button id="undoBtn" class="btn" disabled>元に戻す</button>
    </div>

    <div class="row">
      <span class="slider">寛容度（ざっくり除去用） <input type="range" id="tol" min="0" max="100" value="24" /> <output id="tolOut">24</output></span>
      <button id="autoCornerBtn" class="btn" disabled>自動：四隅から一括除去</button>
      <button id="colorPickBtn" class="btn" disabled>クリック色で除去</button>
      <span class="hint">※ 背景色が均一な画像に有効</span>
    </div>

    <div class="row">
      <div class="seg">
        <input type="radio" name="mode" id="modeErase" value="erase" checked />
        <label for="modeErase">消しゴム</label>
        <input type="radio" name="mode" id="modeRestore" value="restore" />
        <label for="modeRestore">復元ブラシ</label>
      </div>
      <span class="slider">ブラシサイズ <input type="range" id="brush" min="5" max="100" value="32" /> <output id="brushOut">32</output></span>
    </div>

    <div class="row">
      <button id="cropModeBtn" class="btn" disabled>クロップ開始</button>
      <button id="cropCancelBtn" class="btn" disabled>キャンセル</button>
      <button id="autoTrimBtn" class="btn" disabled>自動トリミング（透過外周カット）</button>
      <span class="warn" id="cropHint" style="display:none;">ドラッグで範囲選択 → 指/マウスを離すと自動適用</span>
    </div>
  </div>

  <canvas id="canvas" width="800" height="600"></canvas>

  <p class="warn">※ 石の部分だけ切り抜きたい場合は、<strong>クロップ開始 → 範囲ドラッグ → 指/マウスを離す</strong> で自動適用。外周が完全に透過なら「自動トリミング」が便利です。</p>

  <script>
    // ==== 要素参照（ここが未定義だと ReferenceError になります） ====
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const upload = document.getElementById('upload');
    const saveBtn = document.getElementById('saveBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const undoBtn = document.getElementById('undoBtn');
    const tol = document.getElementById('tol');
    const tolOut = document.getElementById('tolOut');
    const autoCornerBtn = document.getElementById('autoCornerBtn');
    const colorPickBtn = document.getElementById('colorPickBtn');
    const brush = document.getElementById('brush');
    const brushOut = document.getElementById('brushOut');
    const cropModeBtn = document.getElementById('cropModeBtn');
    const cropCancelBtn = document.getElementById('cropCancelBtn');
    const autoTrimBtn = document.getElementById('autoTrimBtn');
    const cropHint = document.getElementById('cropHint');

    // ==== 状態 ====
    let img = new Image();
    let originalImageData = null; // 元画像の保持（復元用）
    let isDrawing = false;
    let mode = 'erase'; // 'erase' | 'restore'
    let history = [];   // Undo用
    const MAX_HISTORY = 20;

    // Crop state
    let cropMode = false;
    let cropStart = null; // {x,y}
    let cropEnd = null;   // {x,y}
    let snapshotBeforeCrop = null; // プレビュー用: 暗幕を描く前のImageData

    // ==== UI制御 ====
    function setEnabled(ready) {
      saveBtn.disabled = !ready;
      downloadBtn.disabled = !ready;
      autoCornerBtn.disabled = !ready;
      colorPickBtn.disabled = !ready;
      undoBtn.disabled = history.length === 0;
      cropModeBtn.disabled = !ready;
      autoTrimBtn.disabled = !ready;
      cropCancelBtn.disabled = !cropMode;
    }

    tol.addEventListener('input', () => tolOut.textContent = tol.value);
    brush.addEventListener('input', () => brushOut.textContent = brush.value);
    document.getElementById('modeErase').addEventListener('change', () => mode = 'erase');
    document.getElementById('modeRestore').addEventListener('change', () => mode = 'restore');

    // 透明外周を自動的にカット
    autoTrimBtn.addEventListener('click', () => {
      const imgData = ctx.getImageData(0,0,canvas.width, canvas.height);
      const { data, width, height } = imgData;
      let minX = width, minY = height, maxX = -1, maxY = -1;
      for (let y=0; y<height; y++) {
        for (let x=0; x<width; x++) {
          const i = (y*width + x)*4 + 3; // alpha
          if (data[i] !== 0) {
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
          }
        }
      }
      if (maxX < 0 || maxY < 0) { alert('全て透過のため、トリミングできません。'); return; }
      const rect = { x: minX, y: minY, w: maxX - minX + 1, h: maxY - minY + 1 };
      applyCropRect(rect);
    });
    
    // ==== アップロード ====
    upload.addEventListener('change', (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        img.onload = () => {
          const maxW = 1400, maxH = 1000;
          let w = img.width, h = img.height;
          const ratio = Math.min(1, maxW / w, maxH / h);
          w = Math.round(w * ratio); h = Math.round(h * ratio);
          canvas.width = w; canvas.height = h;
          ctx.clearRect(0,0,w,h);
          ctx.drawImage(img, 0, 0, w, h);
          originalImageData = ctx.getImageData(0, 0, w, h);
          history = []; pushHistory();
          setEnabled(true);
        };
        img.src = ev.target.result;
      };
      reader.readAsDataURL(file);
    });

    // ==== ユーティリティ ====
    function pushHistory() {
      try {
        history.push(ctx.getImageData(0,0,canvas.width, canvas.height));
        if (history.length > MAX_HISTORY) history.shift();
        undoBtn.disabled = false;
      } catch {}
    }

    undoBtn.addEventListener('click', () => {
      if (history.length <= 1) return;
      history.pop();
      ctx.putImageData(history[history.length - 1], 0, 0);
      undoBtn.disabled = history.length === 1;
    });

    function colorDist(r1,g1,b1, r2,g2,b2) { return Math.hypot(r1-r2, g1-g2, b1-b2); }

    function floodEraseFrom(x, y, tolerance) {
      const imgData = ctx.getImageData(0,0,canvas.width, canvas.height);
      const { data, width, height } = imgData;
      const i0 = (y * width + x) * 4;
      const sr = data[i0], sg = data[i0+1], sb = data[i0+2], sa = data[i0+3];
      if (sa === 0) return;
      const stack = [[x,y]];
      const visited = new Uint8Array(width * height);
      const tolVal = (+tolerance) * 3;
      while (stack.length) {
        const [cx, cy] = stack.pop();
        if (cx < 0 || cy < 0 || cx >= width || cy >= height) continue;
        const idx = cy * width + cx; if (visited[idx]) continue; visited[idx] = 1;
        const p = idx * 4; const r = data[p], g = data[p+1], b = data[p+2], a = data[p+3];
        if (a === 0) continue;
        if (colorDist(r,g,b, sr,sg,sb) <= tolVal) {
          data[p+3] = 0; // 透過
          stack.push([cx+1, cy]); stack.push([cx-1, cy]); stack.push([cx, cy+1]); stack.push([cx, cy-1]);
        }
      }
      ctx.putImageData(imgData, 0, 0);
    }

    autoCornerBtn.addEventListener('click', () => {
      if (!originalImageData) return;
      pushHistory();
      const t = +tol.value;
      floodEraseFrom(0, 0, t);
      floodEraseFrom(canvas.width-1, 0, t);
      floodEraseFrom(0, canvas.height-1, t);
      floodEraseFrom(canvas.width-1, canvas.height-1, t);
    });

    colorPickBtn.addEventListener('click', () => {
      if (!originalImageData) return;
      canvas.style.cursor = 'crosshair';
      const handler = (e) => {
        canvas.removeEventListener('click', handler);
        canvas.style.cursor = '';
        const { x, y } = getPos(e);
        const imgData = ctx.getImageData(0,0,canvas.width, canvas.height);
        const { data, width } = imgData;
        const p0 = (Math.floor(y) * width + Math.floor(x)) * 4;
        const sr = data[p0], sg = data[p0+1], sb = data[p0+2];
        const tolVal = (+tol.value) * 3;
        pushHistory();
        for (let i = 0; i < data.length; i += 4) {
          const r = data[i], g = data[i+1], b = data[i+2];
          if (colorDist(r,g,b, sr,sg,sb) <= tolVal) data[i+3] = 0;
        }
        ctx.putImageData(imgData, 0, 0);
      };
      canvas.addEventListener('click', handler);
    });

    function applyBrush(cx, cy) {
      if (cropMode) return; // クロップ中は描かせない
      const radius = +brush.value / 2;
      const x0 = Math.max(0, Math.floor(cx - radius));
      const y0 = Math.max(0, Math.floor(cy - radius));
      const x1 = Math.min(canvas.width - 1, Math.ceil(cx + radius));
      const y1 = Math.min(canvas.height - 1, Math.ceil(cy + radius));
      const cur = ctx.getImageData(x0, y0, x1 - x0 + 1, y1 - y0 + 1);
      const { data } = cur;
      let orig;
      if (mode === 'restore' && originalImageData) orig = originalImageData;
      const rad2 = radius * radius;
      for (let y = y0; y <= y1; y++) {
        for (let x = x0; x <= x1; x++) {
          const dx = x - cx, dy = y - cy; if (dx*dx + dy*dy > rad2) continue;
          const localX = x - x0, localY = y - y0;
          const p = (localY * (x1 - x0 + 1) + localX) * 4;
          if (mode === 'erase') {
            data[p+3] = 0;
          } else if (mode === 'restore' && orig) {
            const op = (y * canvas.width + x) * 4;
            data[p]   = orig.data[op];
            data[p+1] = orig.data[op+1];
            data[p+2] = orig.data[op+2];
            data[p+3] = orig.data[op+3];
          }
        }
      }
      ctx.putImageData(cur, x0, y0);
    }

    function getPos(evt) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      let cx, cy;
      if (evt.touches && evt.touches[0]) {
        cx = evt.touches[0].clientX - rect.left;
        cy = evt.touches[0].clientY - rect.top;
      } else {
        cx = evt.clientX - rect.left;
        cy = evt.clientY - rect.top;
      }
      return { x: cx * scaleX, y: cy * scaleY };
    }

    // ===== クロップ関連 =====
    cropModeBtn.addEventListener('click', () => {
      if (!originalImageData) return;
      cropMode = true; cropStart = null; cropEnd = null; cropHint.style.display = '';
      // 暗幕を描く前の生画像を保存
      snapshotBeforeCrop = ctx.getImageData(0,0,canvas.width, canvas.height);
      setEnabled(true);
    });

    cropCancelBtn.addEventListener('click', () => {
      cropMode = false; cropStart = null; cropEnd = null; cropHint.style.display = 'none';
      if (snapshotBeforeCrop) ctx.putImageData(snapshotBeforeCrop, 0, 0);
      snapshotBeforeCrop = null;
      setEnabled(true);
    });

    function drawCropPreview() {
      if (!cropMode || !cropStart || !cropEnd || !snapshotBeforeCrop) return;
      // 元画像を戻してから矩形描画（暗幕はプレビューのみ）
      ctx.putImageData(snapshotBeforeCrop, 0, 0);
      const x = Math.min(cropStart.x, cropEnd.x);
      const y = Math.min(cropStart.y, cropEnd.y);
      const w = Math.abs(cropEnd.x - cropStart.x);
      const h = Math.abs(cropEnd.y - cropStart.y);
      if (w < 1 || h < 1) return;
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.fillRect(0,0,canvas.width, canvas.height);
      ctx.clearRect(x, y, w, h);
      ctx.strokeStyle = '#00AEEF';
      ctx.lineWidth = 2;
      ctx.setLineDash([6,4]);
      ctx.strokeRect(x+1, y+1, w-2, h-2);
      ctx.restore();
    }

    function applyCropRect(rect) {
      const { x, y, w, h } = rect;
      if (w <= 0 || h <= 0) return;
      // プレビューの暗幕を含まないソースから切り出す
      const src = document.createElement('canvas');
      src.width = canvas.width; src.height = canvas.height;
      const sctx = src.getContext('2d');
      if (snapshotBeforeCrop) {
        sctx.putImageData(snapshotBeforeCrop, 0, 0);
      } else {
        sctx.drawImage(canvas, 0, 0);
      }
      pushHistory();
      const dest = document.createElement('canvas');
      dest.width = w; dest.height = h;
      const dctx = dest.getContext('2d');
      dctx.clearRect(0,0,w,h);
      dctx.drawImage(src, x, y, w, h, 0, 0, w, h);
      canvas.width = w; canvas.height = h;
      ctx.clearRect(0,0,w,h);
      ctx.drawImage(dest, 0, 0);
      originalImageData = ctx.getImageData(0, 0, w, h);
      history = []; pushHistory();
    }

    function normalizedRect(a, b) {
      const x = Math.max(0, Math.min(a.x, b.x));
      const y = Math.max(0, Math.min(a.y, b.y));
      const x2 = Math.min(canvas.width, Math.max(a.x, b.x));
      const y2 = Math.min(canvas.height, Math.max(a.y, b.y));
      return { x, y, w: Math.max(0, x2 - x), h: Math.max(0, y2 - y) };
    }

    // ==== 入力イベント ====
    canvas.addEventListener('mousedown', (e) => {
      if (!originalImageData) return;
      if (cropMode) {
        const p = getPos(e); cropStart = p; cropEnd = p; drawCropPreview(); return;
      }
      isDrawing = true; pushHistory(); const p = getPos(e); applyBrush(p.x, p.y);
    });

    canvas.addEventListener('mousemove', (e) => {
      if (cropMode && cropStart) { cropEnd = getPos(e); drawCropPreview(); return; }
      if (!isDrawing) return; const p = getPos(e); applyBrush(p.x, p.y);
    });

    window.addEventListener('mouseup', () => {
      if (cropMode && cropStart && cropEnd) {
        const r = normalizedRect(cropStart, cropEnd);
        if (r.w >= 2 && r.h >= 2) { // 誤操作防止
          applyCropRect(r);
        }
        cropMode = false; cropStart = null; cropEnd = null; cropHint.style.display = 'none';
        snapshotBeforeCrop = null; setEnabled(true);
      }
      isDrawing = false;
    });

    canvas.addEventListener('touchstart', (e) => {
      if (!originalImageData) return;
      if (cropMode) { const p = getPos(e); cropStart = p; cropEnd = p; drawCropPreview(); return; }
      isDrawing = true; pushHistory(); const p = getPos(e); applyBrush(p.x, p.y);
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      if (cropMode && cropStart) { cropEnd = getPos(e); drawCropPreview(); e.preventDefault(); return; }
      if (!isDrawing) return; const p = getPos(e); applyBrush(p.x, p.y); e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('touchend', () => {
      if (cropMode && cropStart && cropEnd) {
        const r = normalizedRect(cropStart, cropEnd);
        if (r.w >= 2 && r.h >= 2) { applyCropRect(r); }
        cropMode = false; cropStart = null; cropEnd = null; cropHint.style.display = 'none';
        snapshotBeforeCrop = null; setEnabled(true);
      }
      if (!cropMode) isDrawing = false;
    });

    canvas.addEventListener('touchcancel', () => { if (!cropMode) isDrawing = false; });

    // ==== ダウンロード ====
    function downloadPNG(filename = 'transparent-stone.png') {
      const a = document.createElement('a');
      const supportDownload = 'download' in a;
      if (canvas.toBlob) {
        canvas.toBlob((blob) => {
          if (!blob) return;
          const url = URL.createObjectURL(blob);
          if (!supportDownload) {
            window.open(url, '_blank');
            setTimeout(() => URL.revokeObjectURL(url), 10000);
            return;
          }
          a.href = url;
          a.download = filenameWithTimestamp(filename);
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          setTimeout(() => URL.revokeObjectURL(url), 0);
        }, 'image/png');
      } else {
        const dataURL = canvas.toDataURL('image/png');
        if (!supportDownload) { window.open(dataURL, '_blank'); return; }
        a.href = dataURL;
        a.download = filenameWithTimestamp(filename);
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      }
    }

    function filenameWithTimestamp(base) {
      const t = new Date();
      const pad = (n) => String(n).padStart(2, '0');
      const ts = `${t.getFullYear()}${pad(t.getMonth()+1)}${pad(t.getDate())}-${pad(t.getHours())}${pad(t.getMinutes())}${pad(t.getSeconds())}`;
      const dot = base.lastIndexOf('.');
      const name = dot > -1 ? base.slice(0, dot) : base;
      return `${name}-${ts}.png`;
    }

    saveBtn.addEventListener('click', () => downloadPNG('transparent-stone.png'));
    downloadBtn.addEventListener('click', () => downloadPNG('downloaded-stone.png'));

    // ==== 初期状態 ====
    setEnabled(false);
    tolOut.textContent = tol.value; brushOut.textContent = brush.value;

    // ==== 簡易スモークテスト（コンソール）====
    (function runSmokeTests(){
      const must = [canvas, ctx, upload, saveBtn, downloadBtn, undoBtn, tol, tolOut, autoCornerBtn, colorPickBtn, brush, brushOut, cropModeBtn, cropCancelBtn, autoTrimBtn, cropHint];
      console.assert(must.every(Boolean), '[TEST] DOM要素の取得に失敗していないか確認');
      // 正規化矩形のテスト
      const nr = normalizedRect({x:10,y:10},{x:5,y:5});
      console.assert(nr.x===5 && nr.y===5 && nr.w===5 && nr.h===5, '[TEST] normalizedRect 逆順座標の処理');
    })();
  </script>
</body>
</html>
